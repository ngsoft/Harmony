#!/bin/bash
#
# Harmony Remote Daemon (irexec manager)
# Launched by harmony command if not running, manages irexec processes and flirc hotswap
# As flirc service it detects if the usb is plugged in and launch the process when needed

[ $(pgrep -f -c "/bin/bash ${BASH_SOURCE[0]}") != 1 ] && exit 1

# Can be overriden inside < /etc/default/harmony >
description="Harmony Remote Daemon"
logfile=/tmp/harmony.log
check_intervals=30

[ ! -r /etc/default/harmony ] && echo "Harmony Remote Daemon not installed, please run hrmy-setup."  && exit 1
. /etc/default/harmony
. $prefix/usr/lib/harmony/utils

pid_pattern="^([0-9]+)$"
daemon=irexec
prog=harmony
sudo=gksu
flirc=/etc/init.d/flirc


irprofiles=$prefix/etc/lirc/irexec.conf.d
modules=$prefix/etc/$prog/modules
activities=$prefix/etc/$prog/activities
#main=$prefix/etc/$prog/main

export DISPLAY=:0
export PATH=$prefix/bin:$prefix/usr/lib/harmony:$PATH


do_init(){
    # Check if service is started
    if ! cmd $flirc status; then
        notify "Flirc service is stopped, need to be restarted." "Flirc"
        $sudo $flirc restart 
        cmd $flirc status || throw_error_notify "Cannot start Flirc service, shutting down."
    fi
    do_stop
    # Check if remote control is plugged in
    if cmd flirc-fix; then
        # prevents remote control from sending random
        # keypresses to the wrong windows (LIRC not grabbing the device as inputlirc)
        xinput disable "$device_name"
        flirc-load-conf
        do_start
    fi
    
}

add_pid(){
    [ -z $1 ] && return 1
    [[ $1 =~ $pid_pattern ]] || return 1
    if [ -z $daemonpids ]; then
        $daemonpids=$1
        return 0
    fi
    $daemonpids="$daemonpids $1"
}




do_start(){
    noop
}

do_stop(){
    local pid
    for pid in $daemonpids; do
        cmd kill $pid
    done
    daemonpids=""
}

do_check(){
    noop
}

do_kill(){
    exit 0
}

do_exit(){
    notify "Stopping $description"
    cmd killall $daemon
    cmd xinput enable "$device_name"
}

trap do_exit EXIT
trap do_kill SIGINT SIGTERM SIGQUIT
timer=0
daemonpids=""


notify "Starting $description"

do_init
do_check

while true; do

    if [ $timer -gt $check_intervals ]; then 
        do_check
        timer=0
    fi
    sleep 1
    ((timer++))
done
